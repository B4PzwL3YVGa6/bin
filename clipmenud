#!/bin/bash

: "${CM_ONESHOT=0}"
: "${CM_OWN_CLIPBOARD=1}"
: "${CM_DEBUG=0}"
: "${CM_DIR="${XDG_RUNTIME_DIR-"${TMPDIR-/tmp}"}"}"
: "${CM_MAX_CLIPS=1000}"

cache_dir=$CM_DIR/clipmenu.$USER/
cache_file=$cache_dir/line_cache
lock_file=$cache_dir/lock
lock_timeout=2

xsel_log=/dev/null
for file in /proc/self/fd/2 /dev/stderr; do
    [[ -f "$file" ]] || continue
    [[ -f "$(readlink "$file")" ]] || continue
    xsel_log="$file"
    break
done

_xsel() {
    timeout 1 xsel --logfile "$xsel_log" "$@"
}

get_first_line() {
    data=${1?}
    line_length_limit=${2-300}

    awk -v limit="$line_length_limit" '
        BEGIN { printed = 0; }

        printed == 0 && NF {
            $0 = substr($0, 0, limit);
            printf("%s", $0);
            printed = 1;
        }

        END {
            if (NR > 1) {
                print " (" NR " lines)";
            } else {
                printf("\n");
            }
        }' <<< "$data"
}

debug() {
    if (( CM_DEBUG )); then
        printf '%s\n' "$@" >&2
    fi
}

mkdir -p -m0700 "$cache_dir"

declare -A last_data

exec {lock_fd}> "$lock_file"

while (( CM_ONESHOT )) || sleep "${CM_SLEEP:-0.5}"; do
    if ! flock -x -w "$lock_timeout" "$lock_fd"; then
        if (( CM_ONESHOT )); then
            printf 'ERROR: %s\n' 'Timed out waiting for lock' >&2
            exit 1
        else
            printf 'ERROR: %s\n' \
                'Timed out waiting for lock, skipping this run' >&2
            continue
        fi
    fi

    for selection in clipboard primary; do
        data=$(_xsel -o --"$selection"; printf x)

        debug "Data before stripping: $data"

        data=${data%x}

        debug "Data after stripping: $data"

        if [[ $data != *[^[:space:]]* ]]; then
            debug "Skipping as clipboard is only blank"
            continue
        fi

        if [[ ${last_data[$selection]} == "$data" ]]; then
            debug 'Skipping as last selection is the same as this one'
            continue
        fi

        last_data[$selection]=$data

        first_line=$(get_first_line "$data")

        debug "New clipboard entry on $selection selection: \"$first_line\""

        # Without checking ${last_data[any]}, we often double write since both
        # selections get the same content
        if [[ ${last_data[any]} != "$data" ]]; then
            filename="$cache_dir/$(cksum <<< "$first_line")"
            debug "Writing $data to $filename"
            printf '%s' "$data" > "$filename"

            debug "Writing $first_line to $cache_file"
            printf '%s\n' "$first_line" >> "$cache_file"
        fi

        last_data[any]=$data

        if (( CM_OWN_CLIPBOARD )) && [[ $selection != primary ]]; then
            _xsel -o --"$selection" | _xsel -i --"$selection"
        fi

        if (( CM_MAX_CLIPS )); then
            mapfile -t to_remove < <(
                head -n -"$CM_MAX_CLIPS" "$cache_file" |
                    while read -r line; do cksum <<< "$line"; done
            )
            num_to_remove="${#to_remove[@]}"
            if (( num_to_remove )); then
                debug "Removing $num_to_remove old clips"
                rm -- "${to_remove[@]/#/"$cache_dir/"}"
                trunc_tmp=$(mktemp)
                tail -n "$CM_MAX_CLIPS" "$cache_file" | uniq > "$trunc_tmp"
                mv -- "$trunc_tmp" "$cache_file"
            fi
        fi
    done

    flock -u "$lock_fd"

    if (( CM_ONESHOT )); then
        debug 'Oneshot mode enabled, exiting'
        break
    fi
done
